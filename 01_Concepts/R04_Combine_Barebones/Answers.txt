========================================
iOS / Swift Interview — Concise Answers
Combine Barebones
========================================

----------------------------------------
SECTION 1 — The Publisher-Subscriber Model
----------------------------------------

1) Publisher-Subscriber model:
   a. Publisher, Subscription, Subscriber.
   b. The subscriber requests a specific number of values via the subscription. The publisher won't send more than demanded. This is backpressure.
   c. Nothing happens. Most publishers are lazy—they don't produce values until someone subscribes.

2) Publisher's associated types:
   a. Output (the value type) and Failure (the error type).
   b. The publisher can never emit an error. It always completes successfully or keeps emitting.
   c. Type safety. Output must match Input, Failure must match Failure. The compiler prevents mismatched pipelines.

----------------------------------------
SECTION 2 — Built-in Publishers
----------------------------------------

3) Built-in publishers:
   a. Just emits one value and completes immediately. Failure is Never. Use for wrapping constants or testing.
   b. Future wraps a one-shot async operation. You call a promise closure with success or failure.
   c. Eager. The closure executes immediately on creation, not on subscription. Matters because side effects happen even without subscribers.
   d. Deferred wraps Future so the closure runs only when someone subscribes. Makes it lazy.

4) @Published:
   a. Use the dollar-sign prefix: $propertyName.
   b. It emits in willSet—before the property has changed.
   c. SwiftUI uses objectWillChange (which @Published triggers) to snapshot state before re-rendering.

5) NotificationCenter publisher:
   a. No. It emits indefinitely as long as notifications post.
   b. The AnyCancellable returned from the subscription.
   c. The subscription is cancelled. No more notifications are received.

----------------------------------------
SECTION 3 — Operators
----------------------------------------

6) Transforming operators:
   a. map transforms every value. compactMap transforms and drops nils.
   b. flatMap takes each value, creates a new publisher from it, and flattens the results into one stream. map just transforms values—it can't chain async operations.
   c. When each value triggers a new async operation (e.g., user ID → network fetch for profile).

7) combineLatest, merge, zip:
   a. combineLatest emits a tuple of the latest values whenever any input emits (after all inputs have emitted at least once).
   b. zip waits for one new value from each input before emitting a tuple. Pairs them one-to-one.
   c. merge interleaves values from publishers of the same type into one stream. No tuples—just a flat stream.
   d. combineLatest: form validation (combine latest values of all fields). zip: pairing requests with responses. merge: combining multiple event sources into one stream.

8) Timing operators:
   a. debounce waits for a pause in emissions. It emits the most recent value only after no new values have arrived for a specified duration.
   b. throttle emits at a fixed rate—either the first or last value in each time window. It doesn't wait for silence.
   c. Search-as-you-type: debounce user input by 300ms so you only fire a network request after the user stops typing.

----------------------------------------
SECTION 4 — Subjects
----------------------------------------

9) Subjects:
   a. PassthroughSubject: no stored state. Values pass through to current subscribers. No replay.
   b. CurrentValueSubject: holds a current value. New subscribers immediately receive it. Updated via send or direct assignment.
   c. The value is lost. PassthroughSubject has no buffer.

10) Hiding subjects:
    a. Keep the subject private. Expose a public property typed as AnyPublisher via eraseToAnyPublisher().
    b. It wraps any publisher into the type-erased AnyPublisher, hiding the concrete publisher chain.
    c. It simplifies complex nested generic types. Without erasure, return types become deeply nested and unreadable.

11) Completion behavior:
    a. No. Once completed, a subject emits no more values.
    b. .finished (normal termination) and .failure(Error) (error termination).
    c. When the data source is exhausted or the task is done—e.g., a one-time data load completes.

----------------------------------------
SECTION 5 — Cancellables and Memory Management
----------------------------------------

12) Cancellables:
    a. An AnyCancellable. If you don't store it, it's deallocated immediately and the subscription is cancelled. Nothing happens.
    b. Store them in a Set<AnyCancellable> using .store(in: &cancellables).
    c. When the owning object is deallocated, the set is released, all cancellables are released, and all subscriptions are cancelled.

13) Retain cycles:
    a. self owns a Set<AnyCancellable>. A sink closure captures self strongly. The cancellable is stored in self's set. Cycle: self → set → cancellable → closure → self.
    b. Use [weak self] in the sink closure.
    c. No. It's standard ARC retain cycle behavior. Combine just makes it common because every pipeline ends in a closure.

----------------------------------------
SECTION 6 — Error Handling
----------------------------------------

14) Errors in pipelines:
    a. The error flows downstream and terminates the pipeline. The subscriber receives a .failure completion.
    b. No. An error is a terminal event. No values follow.
    c. Because assign writes to a property continuously. If the pipeline errored, there's no meaningful value to assign.

15) Error recovery:
    a. replaceError substitutes a default value on error, then completes normally. Converts Failure to Never.
    b. catch replaces the failed publisher with an entirely new publisher. Unlike replaceError, the replacement publisher can emit multiple values.
    c. retry resubscribes to the upstream publisher N times before letting the error through.
    d. When the upstream has side effects (e.g., a POST request). Retrying could duplicate mutations.

16) Unifying failure types:
    a. Use mapError to convert both publishers to a common error type, then combine.
    b. mapError transforms the error type, like map for values but for the Failure side.
    c. setFailureType changes a Never-failing publisher's Failure type to match another publisher. No actual error behavior added—just a type signature change.

----------------------------------------
SECTION 7 — Schedulers and Threading
----------------------------------------

17) Schedulers:
    a. receive(on:) switches downstream work to the specified scheduler (e.g., main thread for UI).
    b. subscribe(on:) runs the upstream subscription and publisher work on the specified scheduler.
    c. receive(on:). You almost always need to hop to the main thread before updating UI. subscribe(on:) is only needed when upstream work is expensive and must be off main.

18) RunLoop.main vs DispatchQueue.main:
    a. Mostly, but not perfectly. They both execute on the main thread.
    b. RunLoop.main is tied to run loop modes and may not fire during scrolling or tracking. DispatchQueue.main dispatches as GCD blocks regardless of mode.
    c. DispatchQueue.main. More predictable behavior.

----------------------------------------
SECTION 8 — Combine with SwiftUI and async/await
----------------------------------------

19) Combine and SwiftUI:
    a. ViewModel conforms to ObservableObject. @Published properties automatically trigger objectWillChange. SwiftUI observes the ViewModel.
    b. The objectWillChange publisher on ObservableObject. @Published triggers it in willSet.
    c. @Observable provides per-property tracking without @Published or ObservableObject. Finer-grained—only views reading a specific property re-render when it changes.

20) Bridging to async/await:
    a. Use the .values property on any publisher. It returns an AsyncSequence you iterate with for-await.
    b. Cancellation semantics differ. Combine cancels via AnyCancellable; async/await cancels via Task. Error types may not align cleanly.
    c. Combine: ongoing streams, event processing, combining multiple reactive sources. async/await: one-shot operations, sequential async work. Use whichever is dominant in the layer; bridge at boundaries.

----------------------------------------
SECTION 9 — Practical Scenarios
----------------------------------------

21) Search-as-you-type:
    a. $searchText → debounce → removeDuplicates → filter (non-empty) → flatMap (network request) → receive(on: main) → sink/assign.
    b. debounce waits for a typing pause. removeDuplicates avoids re-fetching for the same query.
    c. flatMap with maxPublishers set to .max(1) cancels the previous inner publisher when a new one starts. Or use switchToLatest after map to a publisher.

22) ViewModel subscription lifecycle:
    a. In a private Set<AnyCancellable> property on the ViewModel.
    b. The set is deallocated, cancellables are released, subscriptions are cancelled. Clean automatic teardown.
    c. Yes, if the sink closure accesses self and the ViewModel owns the cancellable set. Use [weak self] and guard let self inside the closure.

----------------------------------------
WRAP-UP
----------------------------------------

23) Combine vs async/await:
    a. async/await for sequential, one-shot async work. Combine for ongoing streams and reactive transformations.
    b. Yes. Use async/await in your service layer for network calls. Use Combine in your ViewModel to debounce, combine, and transform streams of user input or state changes. Bridge with .values when needed.

----------------------------------------
QUICK MENTAL MODELS
----------------------------------------

Pipeline Model:
  Publisher → Operator chain → Subscriber
  Data flows forward. Errors terminate the pipeline.

Subject Choice:
  PassthroughSubject = events (fire and forget)
  CurrentValueSubject = state (always has a value)

Memory Rule:
  No stored cancellable = no subscription.
  [weak self] in sink when self owns the cancellable set.

Error Rule:
  Errors are terminal. Once an error fires, no more values.
  assign requires Never failure. Use replaceError or catch to get there.

Threading Rule:
  receive(on: DispatchQueue.main) before UI updates.
  That's the one you use 95% of the time.

When to Use Combine:
  Streams, reactive transformations, combining multiple sources.
  For one-shot async: prefer async/await.

========================================
END OF ANSWERS
========================================
