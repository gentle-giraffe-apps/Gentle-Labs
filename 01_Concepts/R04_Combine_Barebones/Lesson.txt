Combine Barebones
A Verbal Lesson

========================================
Part One: The Publisher-Subscriber Model
========================================

Combine is Apple's declarative framework for processing values over time. It was introduced alongside SwiftUI and follows the reactive programming model. The core idea is simple: data flows from a publisher, through a chain of operators, to a subscriber.

A Publisher is a type that declares it can emit a sequence of values and eventually finish, either successfully or with an error. Every publisher declares two associated types: Output, the type of value it produces, and Failure, the type of error it can emit. If a publisher can never fail, its Failure type is Never.

A Subscriber receives values from a publisher. It also declares two associated types: Input and Failure, which must match the publisher's Output and Failure for them to connect.

Between publisher and subscriber sits a Subscription. When a subscriber attaches to a publisher, the publisher creates a subscription and hands it to the subscriber. The subscriber then uses that subscription to request values. This is demand-driven. The subscriber tells the publisher how many values it wants. This is how Combine handles backpressure. The publisher won't flood the subscriber with more values than requested.

In practice, you rarely create custom subscribers. Most of the time you use sink or assign, which are built-in subscribers that handle demand automatically by requesting unlimited values. But understanding the three-piece model, publisher, subscription, subscriber, helps you reason about what's happening under the hood.

========================================
Part Two: Built-in Publishers
========================================

Combine ships with several publishers you'll use constantly.

Just emits a single value and then completes. It never fails. Use it when you need to wrap a known value into the publisher pipeline, often for testing or providing default values.

Future wraps a single asynchronous operation. You give it a closure that receives a promise, and you call that promise exactly once with either success or failure. Future is eager. It executes its closure immediately when created, not when subscribed to. This surprises people. If you want lazy execution, wrap the Future creation in Deferred.

Deferred creates a new publisher each time someone subscribes. It delays the creation of the inner publisher until subscription time. This makes it useful for wrapping eager publishers like Future or for ensuring side effects happen per-subscriber rather than once at creation.

URLSession has a dataTaskPublisher that wraps a network request into a publisher. It emits a single tuple of Data and URLResponse, then completes. This was the primary way to do networking with Combine before async/await.

NotificationCenter has a publisher method that emits notifications matching a given name. This is an ongoing publisher. It doesn't complete on its own. It keeps emitting as long as the subscription is alive.

The @Published property wrapper creates a publisher automatically. Any property marked @Published exposes a publisher via the dollar-sign prefix. When the property changes, the publisher emits the new value. This is the bridge between imperative state changes and reactive pipelines.

Timer has a publish method that creates a publisher emitting at regular intervals. It's a ConnectablePublisher, meaning it doesn't start emitting until you call connect or use autoconnect. This prevents the timer from running before anyone is listening.

========================================
Part Three: Operators
========================================

Operators are where Combine's power lives. An operator takes a publisher as input, transforms it in some way, and returns a new publisher. You chain operators to build processing pipelines.

Transforming operators. Map transforms each value. CompactMap transforms and filters out nils. FlatMap takes each value, creates a new publisher from it, and flattens the results into a single stream. FlatMap is essential for chaining async operations, like taking a user ID and fetching their profile.

Filtering operators. Filter passes through only values that satisfy a predicate. RemoveDuplicates suppresses consecutive duplicate values. First and last take the first or last value and then complete. Debounce waits for a pause in values before emitting the most recent one, perfect for search-as-you-type where you don't want to fire a request on every keystroke.

Combining operators. CombineLatest takes two or more publishers and emits a tuple of the latest value from each whenever any of them emits. Merge combines multiple publishers of the same type into a single stream. Zip pairs values from two publishers, emitting a tuple only when both have produced a new value, like a zipper interleaving teeth.

The key difference between combineLatest, merge, and zip is timing. CombineLatest emits whenever any input emits, using the latest from each. Merge interleaves values as they arrive. Zip waits for one value from each before emitting.

Timing operators. Debounce waits for a pause. Throttle samples at a fixed rate, either first or latest value in the window. Delay shifts all values forward in time. Timeout fails if no value arrives within a deadline.

========================================
Part Four: Subjects
========================================

Subjects are a special kind of publisher that you can push values into imperatively. They bridge the imperative world and the reactive world.

PassthroughSubject doesn't hold any state. When you send a value, it passes directly through to current subscribers. If nobody is subscribed, the value is lost. Think of it as a doorway. Values pass through but don't linger.

CurrentValueSubject holds a current value. When you send a new value, it stores it and emits it to subscribers. When a new subscriber attaches, it immediately receives the current value. Think of it as a variable that also happens to be a publisher. You can read its value property at any time.

When do you use each? Use PassthroughSubject for events, things that happen at a point in time, like button taps or notifications. Use CurrentValueSubject for state, things that always have a current value, like a loading flag or a user's name.

Both subjects conform to the Subject protocol, which means they have a send method. You call send with a value, or send with a completion, either finished or a failure. Once you send a completion, the subject is done. It won't emit any more values. This is a one-way door.

A common pattern is to expose a subject as a publisher in your public API. Your class holds a private PassthroughSubject and exposes it as AnyPublisher using eraseToAnyPublisher. This hides the fact that it's a subject, preventing external code from sending values into it.

========================================
Part Five: Cancellables and Memory Management
========================================

When you subscribe to a publisher, you get back an AnyCancellable. This is a token that represents the subscription. As long as the cancellable is alive, the subscription is active. When the cancellable is deallocated, the subscription is cancelled.

This is Combine's memory management model. If you don't store the cancellable, the subscription is cancelled immediately when the cancellable goes out of scope. This is the number one mistake beginners make. They call sink, don't store the result, and wonder why nothing happens.

The convention is to store cancellables in a Set of AnyCancellable using the store method. You declare a property, typically called cancellables, as a set. Each subscription is stored into it. When the owning object is deallocated, the set is deallocated, all cancellables are released, and all subscriptions are cancelled. Clean and automatic.

For a single subscription, you can store the AnyCancellable in a plain property. For multiple subscriptions, use the set.

Here's where it connects to ARC. Your subscriber closure might capture self. If self owns the cancellable, and the cancellable's closure captures self strongly, you have a retain cycle. Use weak self in sink closures when the subscriber's owner might be deallocated before the publisher completes. This is the same pattern as closures anywhere in Swift, but it comes up constantly in Combine because every pipeline ends with a closure.

========================================
Part Six: Error Handling
========================================

Error handling in Combine is built into the type system. Every publisher declares its Failure type. Operators must preserve or transform that type. You can't just ignore errors.

A publisher with Failure type Never can never fail. This is important because some subscribers, like assign, require Never as the failure type. You can't assign values to a property if the pipeline might error out, because what would you assign on failure?

When you need to remove errors from a pipeline, you have several options. ReplaceError substitutes a default value when an error occurs and then completes normally. Catch intercepts the error and replaces the failed publisher with a new one, letting you recover or provide fallback data. Retry resubscribes to the upstream publisher a given number of times before letting the error through.

TryMap is the throwing variant of map. It lets your transformation throw an error, which converts the pipeline's failure type to Error. There are try variants of many operators: tryFilter, tryCompactMap, tryScan, and so on.

MapError transforms one error type into another. This is useful when you need to unify different error types from different publishers into a single type.

SetFailureType changes a Never-failing publisher's failure type to something specific. It doesn't actually add error behavior. It just changes the type signature so the publisher can be combined with other publishers that do have a failure type.

The mental model is that errors flow downstream just like values. When an error occurs, it terminates the pipeline. No more values are emitted after an error. The subscriber receives the error as a completion event.

========================================
Part Seven: Schedulers and Threading
========================================

A Scheduler in Combine defines where and when code runs. It's an abstraction over threading.

The two most important operators for scheduling are receive on and subscribe on. Receive on changes which scheduler downstream operators and the subscriber run on. Subscribe on changes which scheduler the upstream subscription and publisher work happens on.

In practice, you almost always use receive on. The typical pattern is: do work on a background queue, then switch to the main thread before updating UI. You put receive on DispatchQueue.main right before your sink or assign to ensure UI updates happen on the main thread.

RunLoop.main and DispatchQueue.main are both schedulers that run on the main thread, but they have subtle differences. RunLoop.main is tied to the run loop and processes work in specific modes. DispatchQueue.main dispatches work as GCD blocks. In most cases they're interchangeable, but DispatchQueue.main is the safer default.

Subscribe on is less common. It's useful when the publisher's creation or subscription work is expensive and you want it off the main thread. But most built-in publishers already handle their own threading internally.

An important detail: schedulers don't just determine the thread. They also provide timing services. Debounce and delay take a scheduler parameter because they need to measure time. In tests, you can inject a test scheduler to control time deterministically, the same concept as injecting a clock in async/await code.

========================================
Part Eight: Combine with SwiftUI and async/await
========================================

Combine and SwiftUI were designed to work together. The original pattern was ObservableObject with @Published properties. Your ViewModel conforms to ObservableObject. Properties marked @Published automatically notify SwiftUI when they change. SwiftUI subscribes to the objectWillChange publisher behind the scenes.

With iOS 17's @Observable macro, this pattern is less necessary for simple cases. @Observable provides finer-grained observation without needing @Published or ObservableObject. But Combine is still relevant when you need to build reactive pipelines: debouncing search input, combining multiple data sources, or processing streams of events.

Bridging Combine to async/await goes both directions. To consume a publisher as an async sequence, use the values property. This gives you an AsyncSequence you can iterate with for-await. To wrap an async operation as a publisher, you can use Future or create a custom publisher.

When should you use Combine versus async/await? Use async/await for one-shot operations: fetch data, process it, return. Use Combine when you have ongoing streams of values that need transformation: user input debouncing, real-time updates, combining multiple reactive sources. Use async/await for new code where Combine adds no value over simpler patterns.

The practical rule is: don't mix them unnecessarily within the same layer. If your data layer uses Combine, keep it Combine. If it uses async/await, keep it async/await. Bridge at the boundary between layers when needed.

========================================
Bringing It Together
========================================

Combine is a pipeline system. Data flows from publishers through operators to subscribers. The type system enforces correctness at every step, including error types.

Publishers declare what they emit and how they fail. Operators transform both values and errors. Subscribers consume the final output. Cancellables manage the lifecycle of subscriptions, tying them to the lifetime of the owning object through ARC.

Subjects bridge imperative and reactive code. PassthroughSubject for events, CurrentValueSubject for state. Schedulers control threading, with receive on being the one you use daily.

The framework's main strength is composing complex asynchronous data flows declaratively. Its main weakness is the learning curve and type complexity. When error types don't align, you can spend more time fighting the compiler than writing logic.

Know when to use it and when simpler tools suffice. For reactive streams and event processing, Combine is powerful. For straightforward async operations, async/await is cleaner. In a mature codebase, you'll likely use both, and the skill is knowing where each belongs.
