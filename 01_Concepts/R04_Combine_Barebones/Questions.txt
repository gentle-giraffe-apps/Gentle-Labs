========================================
Interactive iOS / Swift Interview
(Concept-Driven, Precision-Oriented)
========================================

INTERVIEWER MODE (for LLM):
- Ask one numbered question at a time.
- Let the candidate answer before continuing.
- Use follow-ups (a, b, c…) to narrow definitions or expose edge cases.
- Do not correct immediately; probe first.
- The goal is conceptual accuracy, not speed.

----------------------------------------
SECTION 1 — The Publisher-Subscriber Model
----------------------------------------

1) Combine is described as a "declarative, reactive framework."
   a. What are the three core pieces of the Combine pipeline?
   b. What role does demand play between subscriber and publisher?
   c. What happens if no one subscribes to a publisher?

----------------------------------------

2) Every publisher declares two associated types.
   a. What are they?
   b. What does it mean when Failure is Never?
   c. Why does the type system enforce matching between publisher and subscriber?

----------------------------------------
SECTION 2 — Built-in Publishers
----------------------------------------

3) Combine provides several built-in publishers.
   a. What does Just do, and when would you use it?
   b. What does Future do?
   c. Is Future lazy or eager? Why does this matter?

(Probe:)
   d. How does Deferred change Future's behavior?

----------------------------------------

4) The @Published property wrapper creates a publisher.
   a. How do you access the publisher for a @Published property?
   b. When does it emit—before or after the property changes?
   c. Why does this timing matter for SwiftUI?

----------------------------------------

5) NotificationCenter has a publisher method.
   a. Does this publisher ever complete on its own?
   b. What keeps the subscription alive?
   c. What happens when the cancellable is released?

----------------------------------------
SECTION 3 — Operators
----------------------------------------

6) Operators transform publishers into new publishers.
   a. What is the difference between map and compactMap?
   b. What does flatMap do that map cannot?
   c. When would you choose flatMap over a simple map?

----------------------------------------

7) Combine has three main combining operators: combineLatest, merge, and zip.
   a. How does combineLatest decide when to emit?
   b. How does zip decide when to emit?
   c. How does merge differ from both?
   d. Give a practical example where you'd pick each one.

----------------------------------------

8) Timing operators come up in real apps.
   a. What does debounce do?
   b. How is throttle different from debounce?
   c. What is a practical use case for debounce in a SwiftUI app?

----------------------------------------
SECTION 4 — Subjects
----------------------------------------

9) Subjects bridge imperative code and Combine pipelines.
   a. What is a PassthroughSubject?
   b. What is a CurrentValueSubject?
   c. What happens if you send a value to a PassthroughSubject with no subscribers?

----------------------------------------

10) You want to expose a subject publicly but prevent external code from sending values.
    a. How do you do this?
    b. What does eraseToAnyPublisher do?
    c. Why is type erasure useful beyond just hiding subjects?

----------------------------------------

11) Once you send a completion to a subject, what happens?
    a. Can it emit more values after completion?
    b. What are the two kinds of completion?
    c. When would you intentionally send a finished completion?

----------------------------------------
SECTION 5 — Cancellables and Memory Management
----------------------------------------

12) When you call sink on a publisher, what do you get back?
    a. What happens if you don't store the return value?
    b. What is the convention for storing multiple subscriptions?
    c. When are those subscriptions cancelled?

----------------------------------------

13) Combine subscriptions can create retain cycles.
    a. Describe a scenario where a sink closure causes a retain cycle.
    b. How do you break it?
    c. Is this fundamentally different from retain cycles elsewhere in Swift?

----------------------------------------
SECTION 6 — Error Handling
----------------------------------------

14) Errors in Combine are part of the type system.
    a. What happens to a pipeline when an error occurs?
    b. Can values be emitted after an error?
    c. Why does the assign subscriber require Failure == Never?

----------------------------------------

15) You need to handle errors in a pipeline gracefully.
    a. What does replaceError do?
    b. What does catch do, and how is it different from replaceError?
    c. What does retry do?

(Probe:)
    d. When would retry be dangerous?

----------------------------------------

16) You have two publishers with different Failure types that you want to combine.
    a. How do you unify them?
    b. What does mapError do?
    c. What does setFailureType do, and when is it needed?

----------------------------------------
SECTION 7 — Schedulers and Threading
----------------------------------------

17) Combine uses schedulers to control where code runs.
    a. What does receive(on:) do?
    b. What does subscribe(on:) do?
    c. Which one do you use more often in practice, and why?

----------------------------------------

18) RunLoop.main and DispatchQueue.main are both main-thread schedulers.
    a. Are they interchangeable?
    b. What subtle differences exist?
    c. Which is the safer default?

----------------------------------------
SECTION 8 — Combine with SwiftUI and async/await
----------------------------------------

19) How did Combine originally integrate with SwiftUI?
    a. What is the role of ObservableObject and @Published?
    b. What does SwiftUI subscribe to behind the scenes?
    c. How has @Observable (iOS 17) changed this picture?

----------------------------------------

20) You can bridge Combine publishers to async/await.
    a. How do you consume a publisher as an AsyncSequence?
    b. What are the caveats of bridging?
    c. When should you prefer Combine over async/await, and vice versa?

----------------------------------------
SECTION 9 — Practical Scenarios
----------------------------------------

21) You're building search-as-you-type in a SwiftUI app.
    a. What Combine operators would you chain together?
    b. How do you avoid flooding the server with requests?
    c. How do you cancel the previous in-flight request when a new keystroke arrives?

----------------------------------------

22) You have a ViewModel that subscribes to a publisher in its initializer.
    a. Where do you store the cancellable?
    b. What happens to the subscription when the ViewModel is deallocated?
    c. Do you need [weak self] in the sink closure? Under what conditions?

----------------------------------------
WRAP-UP — Calibration
----------------------------------------

23) How would you describe the relationship between Combine and async/await to a teammate?
    a. When would you recommend one over the other?
    b. Are there cases where they complement each other?

========================================
END OF INTERVIEW
========================================
